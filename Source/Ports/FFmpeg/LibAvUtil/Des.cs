/******************************************************************************/
/* This source, or parts thereof, may be used in any software as long the     */
/* license of NostalgicPlayer is keep. See the LICENSE file for more          */
/* information.                                                               */
/******************************************************************************/
using Polycode.NostalgicPlayer.Kit.C;
using Polycode.NostalgicPlayer.Ports.FFmpeg.LibAvUtil.Containers;

namespace Polycode.NostalgicPlayer.Ports.FFmpeg.LibAvUtil
{
	/// <summary>
	/// DES encryption/decryption
	/// </summary>
	public static class Des
	{
		private static readonly uint8_t[] ip_Shuffle =
		[
			6, 14, 22, 30, 38, 46, 54, 62,
			4, 12, 20, 28, 36, 44, 52, 60,
			2, 10, 18, 26, 34, 42, 50, 58,
			0,  8, 16, 24, 32, 40, 48, 56,
			7, 15, 23, 31, 39, 47, 55, 63,
			5, 13, 21, 29, 37, 45, 53, 61,
			3, 11, 19, 27, 35, 43, 51, 59,
			1,  9, 17, 25, 33, 41, 49, 57
		];

		private static readonly uint8_t[] pc1_Shuffle =
		[
			 7, 15, 23, 31, 39, 47, 55,
			63,  6, 14, 22, 30, 38, 46,
			54, 62,  5, 13, 21, 29, 37,
			45, 53, 61,  4, 12, 20, 28,
			 1,  9, 17, 25, 33, 41, 49,
			57,  2, 10, 18, 26, 34, 42,
			50, 58,  3, 11, 19, 27, 35,
			43, 51, 59, 36, 44, 52, 60
		];

		private static readonly uint8_t[] pc2_Shuffle =
		[
			42, 39, 45, 32, 55, 51,
			53, 28, 41, 50, 35, 46,
			33, 37, 44, 52, 30, 48,
			40, 49, 29, 36, 43, 54,
			15,  4, 25, 19,  9,  1,
			26, 16,  5, 11, 23,  8,
			12,  7, 17,  0, 22,  3,
			10, 14,  6, 20, 27, 24
		];

		private static readonly uint32_t[][] s_Boxes_P_Shuffle =
		[
			[
				0x00808200, 0x00000000, 0x00008000, 0x00808202, 0x00808002, 0x00008202, 0x00000002, 0x00008000,
				0x00000200, 0x00808200, 0x00808202, 0x00000200, 0x00800202, 0x00808002, 0x00800000, 0x00000002,
				0x00000202, 0x00800200, 0x00800200, 0x00008200, 0x00008200, 0x00808000, 0x00808000, 0x00800202,
				0x00008002, 0x00800002, 0x00800002, 0x00008002, 0x00000000, 0x00000202, 0x00008202, 0x00800000,
				0x00008000, 0x00808202, 0x00000002, 0x00808000, 0x00808200, 0x00800000, 0x00800000, 0x00000200,
				0x00808002, 0x00008000, 0x00008200, 0x00800002, 0x00000200, 0x00000002, 0x00800202, 0x00008202,
				0x00808202, 0x00008002, 0x00808000, 0x00800202, 0x00800002, 0x00000202, 0x00008202, 0x00808200,
				0x00000202, 0x00800200, 0x00800200, 0x00000000, 0x00008002, 0x00008200, 0x00000000, 0x00808002
			],
			[
				0x40084010, 0x40004000, 0x00004000, 0x00084010, 0x00080000, 0x00000010, 0x40080010, 0x40004010,
				0x40000010, 0x40084010, 0x40084000, 0x40000000, 0x40004000, 0x00080000, 0x00000010, 0x40080010,
				0x00084000, 0x00080010, 0x40004010, 0x00000000, 0x40000000, 0x00004000, 0x00084010, 0x40080000,
				0x00080010, 0x40000010, 0x00000000, 0x00084000, 0x00004010, 0x40084000, 0x40080000, 0x00004010,
				0x00000000, 0x00084010, 0x40080010, 0x00080000, 0x40004010, 0x40080000, 0x40084000, 0x00004000,
				0x40080000, 0x40004000, 0x00000010, 0x40084010, 0x00084010, 0x00000010, 0x00004000, 0x40000000,
				0x00004010, 0x40084000, 0x00080000, 0x40000010, 0x00080010, 0x40004010, 0x40000010, 0x00080010,
				0x00084000, 0x00000000, 0x40004000, 0x00004010, 0x40000000, 0x40080010, 0x40084010, 0x00084000
			],
			[
				0x00000104, 0x04010100, 0x00000000, 0x04010004, 0x04000100, 0x00000000, 0x00010104, 0x04000100,
				0x00010004, 0x04000004, 0x04000004, 0x00010000, 0x04010104, 0x00010004, 0x04010000, 0x00000104,
				0x04000000, 0x00000004, 0x04010100, 0x00000100, 0x00010100, 0x04010000, 0x04010004, 0x00010104,
				0x04000104, 0x00010100, 0x00010000, 0x04000104, 0x00000004, 0x04010104, 0x00000100, 0x04000000,
				0x04010100, 0x04000000, 0x00010004, 0x00000104, 0x00010000, 0x04010100, 0x04000100, 0x00000000,
				0x00000100, 0x00010004, 0x04010104, 0x04000100, 0x04000004, 0x00000100, 0x00000000, 0x04010004,
				0x04000104, 0x00010000, 0x04000000, 0x04010104, 0x00000004, 0x00010104, 0x00010100, 0x04000004,
				0x04010000, 0x04000104, 0x00000104, 0x04010000, 0x00010104, 0x00000004, 0x04010004, 0x00010100
			],
			[
				0x80401000, 0x80001040, 0x80001040, 0x00000040, 0x00401040, 0x80400040, 0x80400000, 0x80001000,
				0x00000000, 0x00401000, 0x00401000, 0x80401040, 0x80000040, 0x00000000, 0x00400040, 0x80400000,
				0x80000000, 0x00001000, 0x00400000, 0x80401000, 0x00000040, 0x00400000, 0x80001000, 0x00001040,
				0x80400040, 0x80000000, 0x00001040, 0x00400040, 0x00001000, 0x00401040, 0x80401040, 0x80000040,
				0x00400040, 0x80400000, 0x00401000, 0x80401040, 0x80000040, 0x00000000, 0x00000000, 0x00401000,
				0x00001040, 0x00400040, 0x80400040, 0x80000000, 0x80401000, 0x80001040, 0x80001040, 0x00000040,
				0x80401040, 0x80000040, 0x80000000, 0x00001000, 0x80400000, 0x80001000, 0x00401040, 0x80400040,
				0x80001000, 0x00001040, 0x00400000, 0x80401000, 0x00000040, 0x00400000, 0x00001000, 0x00401040
			],
			[
				0x00000080, 0x01040080, 0x01040000, 0x21000080, 0x00040000, 0x00000080, 0x20000000, 0x01040000,
				0x20040080, 0x00040000, 0x01000080, 0x20040080, 0x21000080, 0x21040000, 0x00040080, 0x20000000,
				0x01000000, 0x20040000, 0x20040000, 0x00000000, 0x20000080, 0x21040080, 0x21040080, 0x01000080,
				0x21040000, 0x20000080, 0x00000000, 0x21000000, 0x01040080, 0x01000000, 0x21000000, 0x00040080,
				0x00040000, 0x21000080, 0x00000080, 0x01000000, 0x20000000, 0x01040000, 0x21000080, 0x20040080,
				0x01000080, 0x20000000, 0x21040000, 0x01040080, 0x20040080, 0x00000080, 0x01000000, 0x21040000,
				0x21040080, 0x00040080, 0x21000000, 0x21040080, 0x01040000, 0x00000000, 0x20040000, 0x21000000,
				0x00040080, 0x01000080, 0x20000080, 0x00040000, 0x00000000, 0x20040000, 0x01040080, 0x20000080
			],
			[
				0x10000008, 0x10200000, 0x00002000, 0x10202008, 0x10200000, 0x00000008, 0x10202008, 0x00200000,
				0x10002000, 0x00202008, 0x00200000, 0x10000008, 0x00200008, 0x10002000, 0x10000000, 0x00002008,
				0x00000000, 0x00200008, 0x10002008, 0x00002000, 0x00202000, 0x10002008, 0x00000008, 0x10200008,
				0x10200008, 0x00000000, 0x00202008, 0x10202000, 0x00002008, 0x00202000, 0x10202000, 0x10000000,
				0x10002000, 0x00000008, 0x10200008, 0x00202000, 0x10202008, 0x00200000, 0x00002008, 0x10000008,
				0x00200000, 0x10002000, 0x10000000, 0x00002008, 0x10000008, 0x10202008, 0x00202000, 0x10200000,
				0x00202008, 0x10202000, 0x00000000, 0x10200008, 0x00000008, 0x00002000, 0x10200000, 0x00202008,
				0x00002000, 0x00200008, 0x10002008, 0x00000000, 0x10202000, 0x10000000, 0x00200008, 0x10002008
			],
			[
				0x00100000, 0x02100001, 0x02000401, 0x00000000, 0x00000400, 0x02000401, 0x00100401, 0x02100400,
				0x02100401, 0x00100000, 0x00000000, 0x02000001, 0x00000001, 0x02000000, 0x02100001, 0x00000401,
				0x02000400, 0x00100401, 0x00100001, 0x02000400, 0x02000001, 0x02100000, 0x02100400, 0x00100001,
				0x02100000, 0x00000400, 0x00000401, 0x02100401, 0x00100400, 0x00000001, 0x02000000, 0x00100400,
				0x02000000, 0x00100400, 0x00100000, 0x02000401, 0x02000401, 0x02100001, 0x02100001, 0x00000001,
				0x00100001, 0x02000000, 0x02000400, 0x00100000, 0x02100400, 0x00000401, 0x00100401, 0x02100400,
				0x00000401, 0x02000001, 0x02100401, 0x02100000, 0x00100400, 0x00000000, 0x00000001, 0x02100401,
				0x00000000, 0x00100401, 0x02100000, 0x00000400, 0x02000001, 0x02000400, 0x00000400, 0x00100001
			],
			[
				0x08000820, 0x00000800, 0x00020000, 0x08020820, 0x08000000, 0x08000820, 0x00000020, 0x08000000,
				0x00020020, 0x08020000, 0x08020820, 0x00020800, 0x08020800, 0x00020820, 0x00000800, 0x00000020,
				0x08020000, 0x08000020, 0x08000800, 0x00000820, 0x00020800, 0x00020020, 0x08020020, 0x08020800,
				0x00000820, 0x00000000, 0x00000000, 0x08020020, 0x08000020, 0x08000800, 0x00020820, 0x00020000,
				0x00020820, 0x00020000, 0x08020800, 0x00000800, 0x00000020, 0x08020020, 0x00000800, 0x00020820,
				0x08000800, 0x00000020, 0x08000020, 0x08020000, 0x08020020, 0x08000000, 0x00020000, 0x08000820,
				0x00000000, 0x08020820, 0x00020020, 0x08000020, 0x08020000, 0x08000800, 0x08000820, 0x00000000,
				0x08020820, 0x00020800, 0x00020800, 0x00000820, 0x00000820, 0x00020020, 0x08000000, 0x08020800
			],
		];

		/********************************************************************/
		/// <summary>
		/// 
		/// </summary>
		/********************************************************************/
		internal static void Gen_RoundKeys(CPointer<uint64_t> K, uint64_t key)//XX 242
		{
			// Discard parity bits from key and shuffle it into C and D parts
			uint64_t CDn = Shuffle(key, pc1_Shuffle, pc1_Shuffle.Length);

			// Generate round keys
			for (c_int i = 0; i < 16; i++)
			{
				CDn = Key_Shift_Left(CDn);

				if ((i > 1) && (i != 8) && (i != 15))
					CDn = Key_Shift_Left(CDn);

				K[i] = Shuffle(CDn, pc2_Shuffle, pc2_Shuffle.Length);
			}
		}



		/********************************************************************/
		/// <summary>
		/// 
		/// </summary>
		/********************************************************************/
		internal static uint64_t Des_EncDec(uint64_t @in, CPointer<uint64_t> K, c_int decrypt)//XX 256
		{
			// Used to apply round keys in reverse order for decryption
			decrypt = decrypt != 0 ? 15 : 0;

			// Shuffle irrelevant to security but to ease hardware implementations
			@in = Shuffle(@in, ip_Shuffle, ip_Shuffle.Length);

			for (c_int i = 0; i < 16; i++)
			{
				uint32_t f_Res = F_Func((uint32_t)@in, K[decrypt ^ i]);
				@in = (@in << 32) | (@in >> 32);
				@in ^= f_Res;
			}

			@in = (@in << 32) | (@in >> 32);

			// Reverse shuffle used to ease hardware implementations
			@in = Shuffle_Inv(@in, ip_Shuffle, ip_Shuffle.Length);

			return @in;
		}



		/********************************************************************/
		/// <summary>
		/// Allocate an AVDES context
		/// </summary>
		/********************************************************************/
		public static AvDes Av_Des_Alloc()//XX 275
		{
			return Mem.Av_MAllocObj<AvDes>();
		}



		/********************************************************************/
		/// <summary>
		/// Initializes an AVDES context
		/// </summary>
		/********************************************************************/
		public static c_int Av_Des_Init(AvDes d, CPointer<uint8_t> key, c_int key_Bits, c_int decrypt)//XX 280
		{
			if ((key_Bits != 64) && (key_Bits != 192))
				return Error.EINVAL;

			d.Triple_Des = key_Bits > 64 ? 1 : 0;

			Gen_RoundKeys(d.Round_Keys[0], IntReadWrite.Av_RB64(key));

			if (d.Triple_Des != 0)
			{
				Gen_RoundKeys(d.Round_Keys[1], IntReadWrite.Av_RB64(key + 8));
				Gen_RoundKeys(d.Round_Keys[2], IntReadWrite.Av_RB64(key + 16));
			}

			return 0;
		}



		/********************************************************************/
		/// <summary>
		/// Encrypts / decrypts using the DES algorithm
		/// </summary>
		/********************************************************************/
		public static void Av_Des_Crypt(AvDes d, CPointer<uint8_t> dst, CPointer<uint8_t> src, c_int count, CPointer<uint8_t> iv, c_int decrypt)//XX 324
		{
			Av_Des_Crypt_Mac(d, dst, src, count, iv, decrypt, 0);
		}

		#region Private methods
		/********************************************************************/
		/// <summary>
		/// 
		/// </summary>
		/********************************************************************/
		private static uint64_t Shuffle(uint64_t @in, CPointer<uint8_t> shuffle, c_int shuffle_Len)//XX 179
		{
			uint64_t res = 0;

			for (c_int i = 0; i < shuffle_Len; i++)
				res += res + ((@in >> shuffle[0, 1]) & 1);

			return res;
		}



		/********************************************************************/
		/// <summary>
		/// 
		/// </summary>
		/********************************************************************/
		private static uint64_t Shuffle_Inv(uint64_t @in, CPointer<uint8_t> shuffle, c_int shuffle_Len)//XX 188
		{
			uint64_t res = 0;
			shuffle += shuffle_Len - 1;

			for (c_int i = 0; i < shuffle_Len; i++)
			{
				res |= (@in & 1) << shuffle[0, -1];
				@in >>= 1;
			}

			return res;
		}



		/********************************************************************/
		/// <summary>
		/// 
		/// </summary>
		/********************************************************************/
		private static uint32_t F_Func(uint32_t r, uint64_t k)//XX 200
		{
			uint32_t @out = 0;

			// Rotate to get first part of E-shuffle in the lowest 6 bits
			r = (r << 1) | (r >> 31);

			// Apply S-boxes, those compress the data again from 8 * 6 to 8 * 4 bits
			for (c_int i = 7; i >= 0; i--)
			{
				uint8_t tmp = (uint8_t)((r ^ k) & 0x3f);

				@out |= s_Boxes_P_Shuffle[i][tmp];

				// Get next 6 bits of E-shuffle and round key k into the lowest bits
				r = (r >> 4) | (r << 28);
				k >>= 6;
			}

			return @out;
		}



		/********************************************************************/
		/// <summary>
		/// Rotate the two halves of the expanded 56 bit key each 1 bit left
		///
		/// Note: the specification calls this "shift", so I kept it although
		/// it is confusing
		/// </summary>
		/********************************************************************/
		private static uint64_t Key_Shift_Left(uint64_t CDn)//XX 233
		{
			uint64_t carries = (CDn >> 27) & 0x10000001;

			CDn <<= 1;
			CDn &= ~0x10000001LU;
			CDn |= carries;

			return CDn;
		}



		/********************************************************************/
		/// <summary>
		/// 
		/// </summary>
		/********************************************************************/
		private static void Av_Des_Crypt_Mac(AvDes d, CPointer<uint8_t> dst, CPointer<uint8_t> src, c_int count, CPointer<uint8_t> iv, c_int decrypt, c_int mac)//XX 324
		{
			uint64_t iv_Val = iv.IsNotNull ? IntReadWrite.Av_RB64(iv) : 0;

			while (count-- > 0)
			{
				uint64_t src_Val = src.IsNotNull ? IntReadWrite.Av_RB64(src) : 0;
				uint64_t dst_Val;

				if (decrypt != 0)
				{
					uint64_t tmp = src_Val;

					if (d.Triple_Des != 0)
					{
						src_Val = Des_EncDec(src_Val, d.Round_Keys[2], 1);
						src_Val = Des_EncDec(src_Val, d.Round_Keys[1], 0);
					}

					dst_Val = Des_EncDec(src_Val, d.Round_Keys[0], 1) ^ iv_Val;
					iv_Val = iv.IsNotNull ? tmp : 0;
				}
				else
				{
					dst_Val = Des_EncDec(src_Val ^ iv_Val, d.Round_Keys[0], 0);

					if (d.Triple_Des != 0)
					{
						dst_Val = Des_EncDec(dst_Val, d.Round_Keys[1], 1);
						dst_Val = Des_EncDec(dst_Val, d.Round_Keys[2], 0);
					}

					iv_Val = iv.IsNotNull ? dst_Val : 0;
				}

				IntReadWrite.Av_WB64(dst, dst_Val);
				src += 8;

				if (mac == 0)
					dst += 8;
			}

			if (iv.IsNotNull)
				IntReadWrite.Av_WB64(iv, iv_Val);
		}
		#endregion
	}
}
